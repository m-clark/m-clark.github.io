---
title: "Title"
description: |
  blah blah
author:
  - name: Michael Clark
    url: https://m-clark.github.io
date: '`r format(Sys.Date(), "%B %d, %Y")`'
preview: ../../img/198R.png   # apparently no way to change the size displayed via css (ignored) or file (stretched)
output:
  distill::distill_article:
    self_contained: false
    toc: true
    css: ../../styles.css
draft: true
tags: [tags, taggy]
categories:
  - ?
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo      = TRUE, 
  message   = FALSE, 
  warning   = FALSE, 
  comment   = NA,
  cache.rebuild = FALSE,
  cache         = TRUE,
  fig.align = 'center',
  fig.asp = .7,
  dev = 'svg',
  dev.args = list(bg = 'transparent'),
  R.options = list(width = 120),
)

library(tidyverse)
library(broom)
library(kableExtra)
library(visibly)

library(tidyverse)

# set the theme as default
theme_set(theme_clean())

# set other point/line default colors; in most cases, we can use the color from
# default discrete scale for more consistency across plots.
update_geom_defaults('vline',  list(colour = 'gray25',  alpha = .25))  # vlines and hlines are typically not attention grabbers so set alpha
update_geom_defaults('hline',  list(colour = 'gray25',  alpha = .25))  # usually a zero marker
update_geom_defaults('point',  list(colour = '#E69F00', alpha = .5))   # alpha as usually there are many points
update_geom_defaults('line',   list(colour = '#E69F00'))
update_geom_defaults('bar',    list(color  = '#E69F00', fill = '#E69F00'))  
update_geom_defaults('col',    list(color  = '#E69F00', fill = '#E69F00'))
update_geom_defaults('smooth', list(color  = '#E69F00', alpha = .15))
update_geom_defaults('dotplot', list(color  = '#E69F00', fill = '#E69F00'))


ggplot <- function(...) ggplot2::ggplot(...) + 
  # brewer bonus is that it is already part of ggplot2
  # scale_color_brewer(palette = 'Dark2', drop = FALSE, aesthetics = c('color', 'fill'))
  # okabe ito colorblind safe scheme
  scale_color_manual(
    values = c(
      '#E69F00',
      '#56B4E9',
      '#009E73',
      '#F0E442',
      '#0072B2',
      '#D55E00',
      '#CC79A7',
      '#999999'
    ),
    drop = FALSE,
    aesthetics = c('color', 'fill')
  )

kable_df <- function(..., digits = 3) {
  kable(..., digits = digits) %>%
    kable_styling(full_width = F)
}

rnd = tidyext::rnd
```

How to calculate a simple rolling conditional value.


Say that you are doing some marketing analysis and you have daily information for a given time period on your customers and store setting, and other things. One feature you are interested in is the time since they last visited the store.  As mentioned your dataset contains daily information, while your customers only visit sporadically.

Let's define a simple dataset for demonstration.

```{r}
set.seed(123)

df <- tibble(
  id = rep(1:4, e = 25),
  group = rep(c('a', 'b'), e = 50),
  date = rep(seq.Date(Sys.Date() - lubridate::days(24), Sys.Date(), 1), 4),
  visited_store = sample(c(TRUE, FALSE), 100, replace = TRUE, prob = c(1, 5)),
  n_items_purchased = ifelse(
    visited_store, 
    sample(c(0, 1, 2), sum(visited_store), replace = TRUE), 
    NA
  )
)

gtsummary::tbl_summary(df)
summary(df)
```

If we want to add a feature for time since they previously visited the store, how could we do it? Simple differencing doesn't work, because most of our dates are not visits. Grouping 

```{r}
df %>% 
  group_by(id) %>% 
  mutate(
    # days_since_previous = date - lag(date), # = 1 for every day
    # days_since_previous = date - lag(date[visited_store]), # error due to size mismatch
    days_since_previous = date - last(date), # doesn't 'roll', just takes last date in group
    days_since_previous = date - last(date[visited_store]), # doesn't 'roll', just take last date in group that's TRUE
    ) %>% 
  filter(id == 1) %>% 
  print(n = Inf)

```

If we group by visit status, or otherwise only work on visit status, that won't work either except for, e.g. actual visit dates.


What can we do? You might think of creating a for loop that can be applied within group. That would work, but depending on data size that might be slow, and might not easily generalize.

For this setting we actually have an easy if not obvious way to do this. It's vectorized so would be speedy relative to a looped approach. The basic idea is to zero out the non-visit dates, then fill them with the last date.  Now you have a date indicator that only has visit dates.

```{r}
library(lubridate)

df <- df %>% 
  group_by(id) %>% 
  mutate(
    date2 = if_else(visited_store, date, NA_Date_)
  ) %>% 
  fill(date2)
```

Now we just take the difference.

```{r}
df %>% 
  mutate(days_since_last_visit = date - date2) %>% 
  DT::datatable()
```

As another example, we might want the current tally of number of visits to the store. Easy enough.

```{r}
df %>% 
  mutate(
    days_since_last_visit = date - date2,
    total_visits = cumsum(visited_store)
    ) %>% 
  DT::datatable()
```

Now what if we want to keep a running total items purchased to date?  This might be a place were we could try a rolling calculation, but these require a window specification that doesn't really work for this.  I was able to hack slider[^slider] by using an infinite size window, but if we had very large data and more complicated computation, we likely don't want to work on the whole vector up to that instance over and over.  In addition, a direct implementation of cumsum will fail since there are NAs, and it has no argument for to deal with them. However, we can use a similar trick as before by working on a transformed version of the original, replacing missing values with NA.

```{r}
df %>%
  mutate(days_since_last_visit = date - date2,
         total_visits = cumsum(visited_store),) %>%
  # fill(n_items_purchased) %>%
  mutate(
    total_items_purchased = data.table::frollsum(n_items_purchased, n = 1, na.rm = TRUE),
    total_items_purchased2 = slider::slide(n_items_purchased, sum, .before = Inf, na.rm = TRUE), 
    total_items_purchased3 = cumsum(ifelse(is.na(n_items_purchased), 0, n_items_purchased))
  ) %>%
  DT::datatable()
```


[^slider]: The helpfile elucidates the difference between sliding vs. lapply/purrr:map.

If we generalize our

