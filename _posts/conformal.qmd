---
title: "Title"
description: |
  blah blah
author:
  - name: Michael Clark
    url: https://m-clark.github.io
draft: true
format: html

---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo      = TRUE, 
  eval      = TRUE, 
  message   = FALSE,
  warning   = FALSE,
  comment   = NA,
  R.options = list(width = 120),
  cache         = TRUE,
  cache.rebuild = FALSE,
  cache.lazy    = FALSE,
  fig.align = 'center',
  fig.asp   = .7,
  dev       = 'svglite',
  dev.args  = list(bg = 'transparent')
)


library(tidyverse)

theme_clean <- function (
  font_size = 12,
  font_family = "",
  center_axis_labels = FALSE
) {
  
  if (center_axis_labels) {
    haxis_just_x <- 0.5
    vaxis_just_y <- 0.5
    v_rotation_x <- 0
    v_rotation_y <- 0
  }
  else {
    haxis_just_x <- 0
    vaxis_just_y <- 1
    v_rotation_x <- 0
    v_rotation_y <- 0
  }
  
  ggplot2::theme(
    text = ggplot2::element_text(
      family = font_family,
      face   = "plain",
      color  = "gray30",
      size   = font_size,
      hjust  = 0.5,
      vjust  = 0.5,
      angle  = 0,
      lineheight = 0.9,
      margin = ggplot2::margin(),
      debug  = FALSE
    ),
    axis.title.x = ggplot2::element_text(
      hjust = haxis_just_x,
      angle = v_rotation_x,
      size  = 0.8 * font_size
    ),
    axis.title.y = ggplot2::element_text(
      vjust = vaxis_just_y,
      hjust = 0,
      angle = v_rotation_y,
      size  = 0.8 * font_size
    ),
    axis.ticks        = ggplot2::element_line(color = "gray30"),
    title             = ggplot2::element_text(color = "gray30", size = font_size * 1.25),
    plot.subtitle     = ggplot2::element_text(color = "gray30", size = font_size * .75, hjust = 0),
    plot.caption      = ggplot2::element_text(color = "gray30", size = font_size * .5, hjust = 0),
    legend.position   = 'bottom', 
    legend.key        = ggplot2::element_rect(fill = "transparent", color = NA),
    legend.background = ggplot2::element_rect(fill = "transparent", color = NA),
    legend.title      = ggplot2::element_blank(), 
    panel.background  = ggplot2::element_blank(),
    panel.grid        = ggplot2::element_blank(),
    strip.background  = ggplot2::element_blank(),
    plot.background   = ggplot2::element_rect(fill = "transparent", color = NA),
  )
}

# set the theme as default
theme_set(theme_clean())

# set other point/line default colors; in most cases, we can use the color from
# default discrete scale for more consistency across plots.
# paletteer::palettes_d$colorblindr$OkabeIto
update_geom_defaults('vline',   list(color = 'gray25',  alpha = .25))  # vlines and hlines are typically not attention grabbers so set alpha
update_geom_defaults('hline',   list(color = 'gray25',  alpha = .25))  # usually a zero marker
update_geom_defaults('point',   list(color = '#E69F00', alpha = .5))   # alpha as usually there are many points
update_geom_defaults('smooth',  list(color = '#56B4E9', alpha = .15))
update_geom_defaults('line',    list(color = '#56B4E9', alpha = .5))
update_geom_defaults('bar',     list(color = '#E69F00', fill = '#E69F00'))  
update_geom_defaults('col',     list(color = '#E69F00', fill = '#E69F00'))
update_geom_defaults('dotplot', list(color = '#E69F00', fill = '#E69F00'))

# use colorblind safe colors for categories; if you supply a continuous value to
# color you'll get an error, but you just have to use `myplot +
# scale_color_continous()` or whatever to override this; likewise you can always
# override this scale for categorical schemes if desired also. Note that this
# will apply for both color and fill, which is usually what we want.

okabe_ito = c(
  '#E69F00',
  '#56B4E9',
  '#009E73',
  '#F0E442',
  '#0072B2',
  '#D55E00',
  '#CC79A7',
  '#999999'
)

ggplot <- function(...) ggplot2::ggplot(...) + 
  # okabe ito colorblind safe scheme
  scale_color_manual(
    values = okabe_ito,
    drop = FALSE,
    aesthetics = c('color', 'fill')
  )

gt <- function(..., decimals = 2, title = NULL, subtitle = NULL) {
  gt::gt(...) %>% 
    gt::fmt_number(
      columns = where(is.numeric),
      decimals = decimals
    ) %>% 
    gt::tab_header(title = title, subtitle = subtitle) %>% 
    gtExtras::gt_theme_nytimes()
}

gt_theme <-   
  list(
    # report median (IQR) and n (percent) as default stats in `tbl_summary()`
    "tbl_summary-str:continuous_stat" = "{mean} ({sd})",
    "tbl_summary-str:categorical_stat" = "{n} ({p})"
  )

rnd = tidyext::rnd
```

https://arxiv.org/pdf/2107.07511.pdf A Gentle Introduction to Conformal Prediction and Distribution-Free Uncertainty Quantification
Anastasios N. Angelopoulos and Stephen Bates

MC Note: lots of issues with this paper and code vs. notebook stuff. Explanations handwave generic code that isn't in the notebook, they can't even bring themselves to do a simple linear regression example, and they are still using terms like softmax when discussing the regression problem.

- Create prediction intervals for regression problems
- Distribution free, model-mispecified okay (assumes iid)
- Under assumptions and sufficient data, can guarantee coverage (like every other technique one might use)

> Letâ€™s give some intuition to supplement the mathematical understanding from the proof in Appendix D. Roughly, if the scores si correctly rank the inputs from lowest to highest magnitude of model error, then the resulting sets will be smaller for easy inputs and bigger for hard ones. If the scores are bad, in the sense that they do not approximate this ranking, then the sets will be useless. For example, if the scores are random noise, then the sets will contain a random sample of the label space, where that random sample is large
enough to provide valid marginal coverage. This illustrates an important underlying fact about conformal prediction: although the guarantee always holds, the usefulness of the prediction sets is primarily determined by the score function. 


Simple function code From Statistical Learning from a Regreession Perspective 3e, fig 1.9

## Data Setup

```{r}
library(mgcv)
df_ca_housing = read_csv('../data/ca_housing.csv')
```

```{r}
set.seed(123)
N = nrow(df_ca_housing)
test_index = sample(1:N, N/4, replace = FALSE)
train = df_ca_housing %>% slice(-test_index)
test  = df_ca_housing %>% slice(test_index) 

N_train = nrow(train)
N_test  = nrow(test)
```


## Get CP and comparison CI

```{r}
fit = gam(ln_house_value ~ s(MedInc), data = train)

calc_cp_error <- function(
    fit,            # fitted model
    test,           # test data
    y,              # test data target
    interval = .95  # interval width
) {
  
  test_resid = abs(y - predict(fit, newdata = test))
  N = nrow(test)
  k = ceiling((N + 1) * interval)
  q = quantile(test_resid, probs = interval * (N / (N + 1)))
  
  residuals_sorted = sort(test_resid)
  
  cp_error = residuals_sorted[k]
  
  list(cp_error = cp_error, q = q, k = k)
}

res = calc_cp_error(fit, test, y = test$ln_house_value)
res
cp_error = res$cp_error

new_data = tibble(MedInc = median(df_ca_housing$MedInc))
prediction = predict(fit, new_data, se.fit = TRUE)

library(boot)

pred_boot = boot(
  train, 
  function(data, i) 
    predict(gam(ln_house_value ~ s(MedInc), data = data[i,]), newdata = new_data),
  R = 1000
)


# plot(pred_boot)

b_mod = brms::brm(
  ln_house_value ~ s(MedInc),
  train,
  iter    = 2000,
  thin    = 4,
  cores   = 4,
  control = list(adapt_delta = .95)
)

bayes = brms::posterior_predict(b_mod, newdata = new_data)

# not convinced this actually works correctly
library(conformalbayes)
m = loo_conformal(b_mod)
bayes2 = conformalbayes:::predictive_interval.conformal(m, newdata = new_data)

CI = new_data %>% 
  mutate(
    se           = prediction$se.fit[1],
    prediction   = prediction$fit[1],
    cp_error     = cp_error,
    std_lower    = prediction - 1.96*se[1], 
    std_upper    = prediction + 1.96*se[1], 
    cp_lower     = prediction - cp_error, 
    cp_upper     = prediction + cp_error, 
    boot_lower   = quantile(pred_boot$t, .025),
    boot_upper   = quantile(pred_boot$t, .975),
    bayes_lower  = quantile(bayes[,1], .025),
    bayes_upper  = quantile(bayes[,1], .975),
    confbayes_lower = bayes2[,1],
    confbayes_upper = bayes2[,2],
  )

glimpse(CI)

CI = CI %>% 
  select(-c(cp_error, se)) %>% 
  pivot_longer(-c(MedInc, prediction), names_to = 'type') %>% 
  separate(type, into = c('type', 'bound')) %>% 
  pivot_wider(names_from = bound, values_from = value) %>% 
  mutate(
    range = upper - lower,
    one_side = range/2
  )

CI
```

## Plot

```{r}
test %>% 
  mutate(prediction = predict(fit, test)) %>% 
  ggplot(aes(MedInc, prediction)) +
  geom_line() +
  geom_pointrange(
    aes(ymin = lower, ymax = upper, color = type),
    data     = filter(CI, type != 'confbayes'),
    fatten   = 1,
    lwd     = 1,
    alpha    = .75,
    position = position_dodge(width = 2)
  )  +
  lims(y = c(-1, 4))

```


## Other packages/examples

```{r}
library(conformalInference)

# ?conformalInference
# jesus what year is this?
X = train %>% select(MedInc) %>% as.matrix()
y = train$ln_house_value

X_test = test %>% select(MedInc) %>% as.matrix()

# df = data.frame(x = X[,1], y = y)

result = conformal.pred(
  X, 
  y, 
  X_test, 
  \(x, y, out) {
    df = data.frame(x = x[,1], y = y)
    gam(y ~ s(x), data = df)
  },
  \(out, newx) predict.gam(out, newdata = data.frame(x = newx[,1])), 
  alpha = .05, 
  num.grid.pts = 100
)



(result$up-result$lo)[1]/2
cp_error
```

```{r}
x = c(17,20,10,17,12,15,19,22,17,19,14,22,18,17,13,12,18,15,17) # n20 = 16
c(mean(x), sd(x))
predict(lm(x~1), newdata=data.frame(x=20), interval = 'p')[1,]
# predict(lm(x~1), newdata=data.frame(x=20), interval = 'c')[1,]
```


## Simulation

```{r}
df_ca_housing = read_csv('data/ca_housing_full.csv')

sim_test_size <- function(test_prop = .1) {
  N = nrow(df_ca_housing)
  test_index = sample(1:N, round(N*test_prop), replace = FALSE)
  train = df_ca_housing %>% slice(-test_index)
  test  = df_ca_housing %>% slice(test_index) 
  
  N_train = nrow(train)
  N_test  = nrow(test)
  
  fit = gam(ln_house_value ~ s(MedInc), data = train)
  calc_cp_error(fit, test, y = test$ln_house_value)
}

sims = map_df(
  seq(.01, .5, .005), 
  \(p) tibble(N_test = nrow(df_ca_housing)*p, error = sim_test_size())
)

sims %>% 
  ggplot(aes(x = N_test, y = error)) +
  geom_point() +
  geom_smooth(se = FALSE)
```

